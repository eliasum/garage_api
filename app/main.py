# 2025.11.27 18:43 IMM

from typing import Any, Dict

from fastapi import FastAPI

# FastAPI (реактивный, событийно-ориентированный)
# Что это: Приложение, которое ждет запросов и реагирует на них.
# Аналог из жизни: Работа курьерского сервиса. Ты ждешь заказов, и когда приходит заказ, выполняешь его.


# Определяем класс Part (Запчасть).
# Класс - это чертеж для создания объектов. Аналогично class в C#.
class Part:
    # Метод __init__ (дАндер-инИт) - это конструктор объекта. Вызывается
    # при создании нового экземпляра класса (новой запчасти).
    # 'self' - это ссылка на текущий экземпляр объекта (аналогично
    # 'this' в C#). Все методы класса первым аргументом принимают self.
    # id: int, name: str - это аннотации типов (type hints). Python их игнорирует при
    # выполнении, но они помогают разработчикам и IDE понимать, какие типы данных ожидаются.
    def __init__(self, id: int, name: str, part_number: str, quantity: int):
        # Создаем атрибуты (поля) объекта и присваиваем им значения, переданные в конструктор.
        self.id = id  # Уникальный идентификатор запчасти
        self.name = name  # Название запчасти (например, "Масляный фильтр")
        self.part_number = part_number  # Каталожный номер
        self.quantity = quantity  # Количество на складе

    # Магический метод __str__ (# дАндер-стр). Определяет, как объект будет преобразован в строку
    # при вызове str(part) или print(part). Аналогично переопределению метода ToString() в C#.
    def __str__(self):
        # Возвращаем форматированную строку (f-string). Выражения
        # в фигурных скобках {} вычисляются и подставляются в строку.
        return f"Part(id={self.id}, name='{self.name}', part_number='{self.part_number}', quantity={self.quantity})"


# Класс Garage (Гараж) представляет собой "репозиторий" или "сервис" для управления запчастями.
class Garage:
    def __init__(self):
        # Инициализируем пустой список для хранения всех запчастей.
        # Список (list) в Python - это аналог List<T> в C#. Изменяемая коллекция.
        self.parts = list()
        # Счетчик для автоматической генерации уникальных ID для новых запчастей.
        self.next_id = 1

    # Метод для добавления новой запчасти.
    def add_part(self, name: str, part_number: str, quantity: int):
        # Создаем новый объект Part, передавая текущий next_id в качестве ID.
        part = Part(self.next_id, name, part_number, quantity)
        # Добавляем созданный объект в список parts.
        self.parts.append(part)  # append - аналог Add() для List<T> в C#.
        # Увеличиваем счетчик ID для следующей запчасти.
        self.next_id += 1

    # Метод для получения списка всех запчастей.
    def list_parts(self):
        # Просто возвращаем весь список parts.
        return self.parts.copy()  # ✅ Возвращаем копию, а не оригинал

    # Метод для поиска запчасти по её ID.
    def find_part(self, part_id: int):
        # Проходим циклом for по всем запчастям в списке self.parts.
        # Цикл for в Python похож на foreach в C#.
        for part in self.parts:
            # Если ID текущей запчасти в цикле совпадает с искомым...
            if part.id == part_id:
                # ...возвращаем эту запчасть.
                return part
        # Если цикл завершился, а запчасть не найдена, возвращаем None (аналог null в C#).
        return None


# СОЗДАЕМ FASTAPI ПРИЛОЖЕНИЕ
app = FastAPI(title="Garage API", description="API для учета запчастей в гараже")

# СОЗДАЕМ ГЛОБАЛЬНЫЙ ЭКЗЕМПЛЯР ГАРАЖА (пока в памяти)
garage = Garage()


# ПЕРВЫЙ ЭНДПОИНТ - просто проверка работы
@app.get("/")
def read_root():
    return {
        "message": "Garage API работает!",
        "endpoints": {"parts_list": "/parts", "health_check": "/health"},
    }


@app.get("/health")
def health_check() -> Dict[str, Any]:  # для формирования документации
    return {"status": "OK", "total_parts": len(garage.list_parts())}


# ЗАПУСК (оставляем на случай прямого запуска файла)
# Как работает: Запускается веб-сервер (uvicorn), который начинает "слушать" порт 8000
# Время жизни: Сервер работает бесконечно (пока его не остановят), ожидая HTTP-запросы
# Пример из жизни: Открыл магазин и ждешь клиентов 24/7
if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)

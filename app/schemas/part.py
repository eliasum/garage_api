# 1️⃣ СИМВОЛ РЕШЁТКИ (#)
# В Python символ # начинает однострочный комментарий.
# Всё, что идёт после # до конца строки, игнорируется интерпретатором.
# Это как // в C#.

# 2️⃣ ИМПОРТЫ (КЛЮЧЕВОЕ СЛОВО from...import)
from pydantic import BaseModel, Field

# from = "из" (англ.)
# pydantic = название библиотеки, которую мы установили через pip
# import = "импортировать" (англ.)
# BaseModel = базовый класс Pydantic, от которого наследуются все схемы
# Field = класс для добавления дополнительных правил к полям
# Запятая между BaseModel и Field = перечисление того, что мы импортируем
# Вся строка = "из библиотеки pydantic импортируй классы BaseModel и Field"


# 3️⃣ ОПРЕДЕЛЕНИЕ КЛАССА (class)
class PartBase(BaseModel):
    # class = ключевое слово Python для создания класса (как в C#)
    # PartBase = имя нашего класса (придумываем сами)
    # (BaseModel) = в скобках указываем родительский класс
    # : = двоеточие начинает блок кода класса (тело класса)
    # Отступ (4 пробела) = в Python вместо фигурных скобок {} используют отступы

    """Базовая схема с общими полями"""

    # Тройные кавычки (""" """) создают строку документации (docstring)
    # Это многострочный комментарий, который Python сохраняет и может показывать
    # Аналог XML-комментариев в C#: /// <summary>

    # 4️⃣ ОБЪЯВЛЕНИЕ ПОЛЕЙ КЛАССА
    name: str = Field(
        ...,  # Первый аргумент Field - значение по умолчанию
        # ... (троеточие) = специальное значение Python "Ellipsis"
        # Означает "это поле ОБЯЗАТЕЛЬНОЕ, без значения по умолчанию"
        # Аналог `required` в C# атрибутах
        min_length=1,  # Параметр Field: минимальная длина строки
        max_length=100,  # Параметр Field: максимальная длина строки
        description="Название запчасти",  # Параметр Field: описание поля
        # description используется для автоматической документации в Swagger UI
    )
    # Полная декларация:
    # name = имя поля (атрибута) класса
    # : = разделитель между именем поля и его типом
    # str = тип данных "string" (строка)
    # = Field(...) = использование класса Field для добавления правил валидации

    part_number: str = Field(
        ...,  # Опять обязательное поле
        pattern=r"^[A-Z]{3}-\d{3}$",  # Регулярное выражение для проверки формата
        # r перед строкой = "raw string" (сырая строка)
        # Позволяет писать обратные слеши \ без их экранирования
        # ^ = начало строки
        # [A-Z]{3} = ровно три заглавные буквы от A до Z
        # - = дефис (обязательный символ)
        # \d{3} = ровно три цифры
        # $ = конец строки
        # Итого: формат "ABC-123"
        description="Каталожный номер в формате ABC-123",
    )

    quantity: int = Field(
        default=1,  # Значение по умолчанию = 1 (если поле не передано)
        # default в Python = аналог присваивания значения по умолчанию в C#
        gt=0,  # greater than (больше чем) 0
        # Валидация: значение должно быть > 0
        description="Количество на складе",
    )
    # int = integer (целое число)


# 5️⃣ ПУСТАЯ СТРОКА (разделитель между классами)
# В Python пустые строки используются для визуального разделения кода
# Не влияют на выполнение, но улучшают читаемость


# 6️⃣ НАСЛЕДОВАНИЕ КЛАССОВ
class PartCreate(PartBase):
    # PartCreate = имя нового класса
    # (PartBase) = наследуем от PartBase (получаем все его поля)

    """Схема для СОЗДАНИЯ запчасти (наследует PartBase)"""

    # Этот класс пока идентичен PartBase, но создан для будущего расширения

    pass  # Ключевое слово pass = "ничего не делать"
    # Нужен потому, что в Python тело класса не может быть пустым
    # Аналог пустых фигурных скобок {} в C#


# 7️⃣ СЛОЖНОЕ НАСЛЕДОВАНИЕ С ДОБАВЛЕНИЕМ ПОЛЯ
class PartResponse(PartBase):
    # Наследуем все поля из PartBase и добавляем свои

    """Схема для ОТВЕТА API (наследует PartBase + добавляет id)"""

    id: int  # Добавляем новое поле - ID запчасти
    # Тип int, без Field() - значит только базовая проверка типа

    # 8️⃣ ВЛОЖЕННЫЙ КЛАСС Config
    class Config:
        # Вложенный класс с именем Config
        # Pydantic ищет именно такой класс для специальных настроек

        from_attributes = True
        # = (присваивание) устанавливает значение True
        # from_attributes = опция Pydantic
        # True = разрешить создание объектов схем из ORM-моделей
        # Например, из SQLAlchemy или Django ORM
        # Аналог автомаппинга в C# Entity Framework

        # Если бы было False или параметр отсутствовал,
        # пришлось бы вручную преобразовывать ORM-объекты в словари
